"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-wallet";
exports.ids = ["vendor-chunks/ethereumjs-wallet"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereumjs-wallet/dist/hdkey.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-wallet/dist/hdkey.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst index_1 = __importDefault(__webpack_require__(/*! ./index */ \"(ssr)/./node_modules/ethereumjs-wallet/dist/index.js\"));\nconst hdkey_1 = __webpack_require__(/*! ethereum-cryptography/hdkey */ \"(ssr)/./node_modules/ethereum-cryptography/hdkey.js\");\nclass EthereumHDKey {\n    constructor(_hdkey) {\n        this._hdkey = _hdkey;\n    }\n    /**\n     * Creates an instance based on a seed.\n     *\n     * For the seed we suggest to use [bip39](https://npmjs.org/package/bip39) to\n     * create one from a BIP39 mnemonic.\n     */\n    static fromMasterSeed(seedBuffer) {\n        return new EthereumHDKey(hdkey_1.HDKey.fromMasterSeed(seedBuffer));\n    }\n    /**\n     * Create an instance based on a BIP32 extended private or public key.\n     */\n    static fromExtendedKey(base58Key) {\n        return new EthereumHDKey(hdkey_1.HDKey.fromExtendedKey(base58Key));\n    }\n    /**\n     * Returns a BIP32 extended private key (xprv)\n     */\n    privateExtendedKey() {\n        if (!this._hdkey.privateExtendedKey) {\n            throw new Error('This is a public key only wallet');\n        }\n        return this._hdkey.privateExtendedKey;\n    }\n    /**\n     * Return a BIP32 extended public key (xpub)\n     */\n    publicExtendedKey() {\n        return this._hdkey.publicExtendedKey;\n    }\n    /**\n     * Derives a node based on a path (e.g. m/44'/0'/0/1)\n     */\n    derivePath(path) {\n        return new EthereumHDKey(this._hdkey.derive(path));\n    }\n    /**\n     * Derive a node based on a child index\n     */\n    deriveChild(index) {\n        return new EthereumHDKey(this._hdkey.deriveChild(index));\n    }\n    /**\n     * Return a `Wallet` instance as seen above\n     */\n    getWallet() {\n        if (this._hdkey._privateKey) {\n            return index_1.default.fromPrivateKey(this._hdkey._privateKey);\n        }\n        return index_1.default.fromPublicKey(this._hdkey._publicKey, true);\n    }\n}\nexports[\"default\"] = EthereumHDKey;\n//# sourceMappingURL=hdkey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC9oZGtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLHFFQUFTO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHdGQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb3hpbWEvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC9oZGtleS5qcz81ZmUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaW5kZXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9pbmRleFwiKSk7XG5jb25zdCBoZGtleV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9oZGtleVwiKTtcbmNsYXNzIEV0aGVyZXVtSERLZXkge1xuICAgIGNvbnN0cnVjdG9yKF9oZGtleSkge1xuICAgICAgICB0aGlzLl9oZGtleSA9IF9oZGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBiYXNlZCBvbiBhIHNlZWQuXG4gICAgICpcbiAgICAgKiBGb3IgdGhlIHNlZWQgd2Ugc3VnZ2VzdCB0byB1c2UgW2JpcDM5XShodHRwczovL25wbWpzLm9yZy9wYWNrYWdlL2JpcDM5KSB0b1xuICAgICAqIGNyZWF0ZSBvbmUgZnJvbSBhIEJJUDM5IG1uZW1vbmljLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTWFzdGVyU2VlZChzZWVkQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXRoZXJldW1IREtleShoZGtleV8xLkhES2V5LmZyb21NYXN0ZXJTZWVkKHNlZWRCdWZmZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGJhc2VkIG9uIGEgQklQMzIgZXh0ZW5kZWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRLZXkoYmFzZTU4S2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRXRoZXJldW1IREtleShoZGtleV8xLkhES2V5LmZyb21FeHRlbmRlZEtleShiYXNlNThLZXkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJJUDMyIGV4dGVuZGVkIHByaXZhdGUga2V5ICh4cHJ2KVxuICAgICAqL1xuICAgIHByaXZhdGVFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZGtleS5wcml2YXRlRXh0ZW5kZWRLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyBhIHB1YmxpYyBrZXkgb25seSB3YWxsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGRrZXkucHJpdmF0ZUV4dGVuZGVkS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBCSVAzMiBleHRlbmRlZCBwdWJsaWMga2V5ICh4cHViKVxuICAgICAqL1xuICAgIHB1YmxpY0V4dGVuZGVkS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGRrZXkucHVibGljRXh0ZW5kZWRLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBub2RlIGJhc2VkIG9uIGEgcGF0aCAoZS5nLiBtLzQ0Jy8wJy8wLzEpXG4gICAgICovXG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXRoZXJldW1IREtleSh0aGlzLl9oZGtleS5kZXJpdmUocGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmUgYSBub2RlIGJhc2VkIG9uIGEgY2hpbGQgaW5kZXhcbiAgICAgKi9cbiAgICBkZXJpdmVDaGlsZChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEV0aGVyZXVtSERLZXkodGhpcy5faGRrZXkuZGVyaXZlQ2hpbGQoaW5kZXgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYFdhbGxldGAgaW5zdGFuY2UgYXMgc2VlbiBhYm92ZVxuICAgICAqL1xuICAgIGdldFdhbGxldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hka2V5Ll9wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfMS5kZWZhdWx0LmZyb21Qcml2YXRlS2V5KHRoaXMuX2hka2V5Ll9wcml2YXRlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhfMS5kZWZhdWx0LmZyb21QdWJsaWNLZXkodGhpcy5faGRrZXkuX3B1YmxpY0tleSwgdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRXRoZXJldW1IREtleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhka2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-wallet/dist/hdkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-wallet/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-wallet/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.thirdparty = exports.hdkey = void 0;\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ \"(ssr)/./node_modules/ethereumjs-util/dist/index.js\");\nconst scrypt_js_1 = __webpack_require__(/*! scrypt-js */ \"(ssr)/./node_modules/scrypt-js/scrypt.js\");\nvar hdkey_1 = __webpack_require__(/*! ./hdkey */ \"(ssr)/./node_modules/ethereumjs-wallet/dist/hdkey.js\");\nObject.defineProperty(exports, \"hdkey\", ({ enumerable: true, get: function () { return __importDefault(hdkey_1).default; } }));\nvar thirdparty_1 = __webpack_require__(/*! ./thirdparty */ \"(ssr)/./node_modules/ethereumjs-wallet/dist/thirdparty.js\");\nObject.defineProperty(exports, \"thirdparty\", ({ enumerable: true, get: function () { return __importDefault(thirdparty_1).default; } }));\nconst bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/bs58check/index.js\");\nconst randomBytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/randombytes/index.js\");\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nfunction validateHexString(paramName, str, length) {\n    if (str.toLowerCase().startsWith('0x')) {\n        str = str.slice(2);\n    }\n    if (!str && !length) {\n        return str;\n    }\n    if (length % 2) {\n        throw new Error(`Invalid length argument, must be an even number`);\n    }\n    if (typeof length === 'number' && str.length !== length) {\n        throw new Error(`Invalid ${paramName}, string must be ${length} hex characters`);\n    }\n    if (!/^([0-9a-f]{2})+$/i.test(str)) {\n        const howMany = typeof length === 'number' ? length : 'empty or a non-zero even number of';\n        throw new Error(`Invalid ${paramName}, string must be ${howMany} hex characters`);\n    }\n    return str;\n}\nfunction validateBuffer(paramName, buff, length) {\n    if (!Buffer.isBuffer(buff)) {\n        const howManyHex = typeof length === 'number' ? `${length * 2}` : 'empty or a non-zero even number of';\n        const howManyBytes = typeof length === 'number' ? ` (${length} bytes)` : '';\n        throw new Error(`Invalid ${paramName}, must be a string (${howManyHex} hex characters) or buffer${howManyBytes}`);\n    }\n    if (typeof length === 'number' && buff.length !== length) {\n        throw new Error(`Invalid ${paramName}, buffer must be ${length} bytes`);\n    }\n    return buff;\n}\nfunction mergeToV3ParamsWithDefaults(params) {\n    const v3Defaults = {\n        cipher: 'aes-128-ctr',\n        kdf: 'scrypt',\n        salt: randomBytes(32),\n        iv: randomBytes(16),\n        uuid: randomBytes(16),\n        dklen: 32,\n        c: 262144,\n        n: 262144,\n        r: 8,\n        p: 1,\n    };\n    if (!params) {\n        return v3Defaults;\n    }\n    if (typeof params.salt === 'string') {\n        params.salt = Buffer.from(validateHexString('salt', params.salt), 'hex');\n    }\n    if (typeof params.iv === 'string') {\n        params.iv = Buffer.from(validateHexString('iv', params.iv, 32), 'hex');\n    }\n    if (typeof params.uuid === 'string') {\n        params.uuid = Buffer.from(validateHexString('uuid', params.uuid, 32), 'hex');\n    }\n    if (params.salt) {\n        validateBuffer('salt', params.salt);\n    }\n    if (params.iv) {\n        validateBuffer('iv', params.iv, 16);\n    }\n    if (params.uuid) {\n        validateBuffer('uuid', params.uuid, 16);\n    }\n    return Object.assign(Object.assign({}, v3Defaults), params);\n}\nfunction kdfParamsForPBKDF(opts) {\n    return {\n        dklen: opts.dklen,\n        salt: opts.salt,\n        c: opts.c,\n        prf: 'hmac-sha256',\n    };\n}\nfunction kdfParamsForScrypt(opts) {\n    return {\n        dklen: opts.dklen,\n        salt: opts.salt,\n        n: opts.n,\n        r: opts.r,\n        p: opts.p,\n    };\n}\n// wallet implementation\nclass Wallet {\n    constructor(privateKey, publicKey = undefined) {\n        this.privateKey = privateKey;\n        this.publicKey = publicKey;\n        if (privateKey && publicKey) {\n            throw new Error('Cannot supply both a private and a public key to the constructor');\n        }\n        if (privateKey && !(0, ethereumjs_util_1.isValidPrivate)(privateKey)) {\n            throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');\n        }\n        if (publicKey && !(0, ethereumjs_util_1.isValidPublic)(publicKey)) {\n            throw new Error('Invalid public key');\n        }\n    }\n    // static methods\n    /**\n     * Create an instance based on a new random key.\n     *\n     * @param icapDirect setting this to `true` will generate an address suitable for the `ICAP Direct mode`\n     */\n    static generate(icapDirect = false) {\n        if (icapDirect) {\n            const max = new ethereumjs_util_1.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);\n            while (true) {\n                const privateKey = randomBytes(32);\n                if (new ethereumjs_util_1.BN((0, ethereumjs_util_1.privateToAddress)(privateKey)).lte(max)) {\n                    return new Wallet(privateKey);\n                }\n            }\n        }\n        else {\n            return new Wallet(randomBytes(32));\n        }\n    }\n    /**\n     * Create an instance where the address is valid against the supplied pattern (**this will be very slow**)\n     */\n    static generateVanityAddress(pattern) {\n        if (!(pattern instanceof RegExp)) {\n            pattern = new RegExp(pattern);\n        }\n        while (true) {\n            const privateKey = randomBytes(32);\n            const address = (0, ethereumjs_util_1.privateToAddress)(privateKey);\n            if (pattern.test(address.toString('hex'))) {\n                return new Wallet(privateKey);\n            }\n        }\n    }\n    /**\n     * Create an instance based on a public key (certain methods will not be available)\n     *\n     * This method only accepts uncompressed Ethereum-style public keys, unless\n     * the `nonStrict` flag is set to true.\n     */\n    static fromPublicKey(publicKey, nonStrict = false) {\n        if (nonStrict) {\n            publicKey = (0, ethereumjs_util_1.importPublic)(publicKey);\n        }\n        return new Wallet(undefined, publicKey);\n    }\n    /**\n     * Create an instance based on a BIP32 extended public key (xpub)\n     */\n    static fromExtendedPublicKey(extendedPublicKey) {\n        if (extendedPublicKey.slice(0, 4) !== 'xpub') {\n            throw new Error('Not an extended public key');\n        }\n        const publicKey = bs58check.decode(extendedPublicKey).slice(45);\n        // Convert to an Ethereum public key\n        return Wallet.fromPublicKey(publicKey, true);\n    }\n    /**\n     * Create an instance based on a raw private key\n     */\n    static fromPrivateKey(privateKey) {\n        return new Wallet(privateKey);\n    }\n    /**\n     * Create an instance based on a BIP32 extended private key (xprv)\n     */\n    static fromExtendedPrivateKey(extendedPrivateKey) {\n        if (extendedPrivateKey.slice(0, 4) !== 'xprv') {\n            throw new Error('Not an extended private key');\n        }\n        const tmp = bs58check.decode(extendedPrivateKey);\n        if (tmp[45] !== 0) {\n            throw new Error('Invalid extended private key');\n        }\n        return Wallet.fromPrivateKey(tmp.slice(46));\n    }\n    /**\n     * Import a wallet (Version 1 of the Ethereum wallet format).\n     *\n     * @param input A JSON serialized string, or an object representing V1 Keystore.\n     * @param password The keystore password.\n     */\n    static async fromV1(input, password) {\n        const json = typeof input === 'object' ? input : JSON.parse(input);\n        if (json.Version !== '1') {\n            throw new Error('Not a V1 Wallet');\n        }\n        if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {\n            throw new Error('Unsupported key derivation scheme');\n        }\n        const kdfparams = json.Crypto.KeyHeader.KdfParams;\n        const derivedKey = await (0, scrypt_js_1.scrypt)(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen);\n        const ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');\n        const mac = (0, ethereumjs_util_1.keccak256)(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));\n        if (mac.toString('hex') !== json.Crypto.MAC) {\n            throw new Error('Key derivation failed - possibly wrong passphrase');\n        }\n        const decipher = crypto.createDecipheriv('aes-128-cbc', (0, ethereumjs_util_1.keccak256)(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));\n        const seed = runCipherBuffer(decipher, ciphertext);\n        return new Wallet(seed);\n    }\n    /**\n     * Import a wallet (Version 3 of the Ethereum wallet format). Set `nonStrict` true to accept files with mixed-caps.\n     *\n     * @param input A JSON serialized string, or an object representing V3 Keystore.\n     * @param password The keystore password.\n     */\n    static async fromV3(input, password, nonStrict = false) {\n        const json = typeof input === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);\n        if (json.version !== 3) {\n            throw new Error('Not a V3 wallet');\n        }\n        let derivedKey, kdfparams;\n        if (json.crypto.kdf === 'scrypt') {\n            kdfparams = json.crypto.kdfparams;\n            // FIXME: support progress reporting callback\n            derivedKey = await (0, scrypt_js_1.scrypt)(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        }\n        else if (json.crypto.kdf === 'pbkdf2') {\n            kdfparams = json.crypto.kdfparams;\n            if (kdfparams.prf !== 'hmac-sha256') {\n                throw new Error('Unsupported parameters to PBKDF2');\n            }\n            derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n        }\n        else {\n            throw new Error('Unsupported key derivation scheme');\n        }\n        const ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n        const mac = (0, ethereumjs_util_1.keccak256)(Buffer.concat([Buffer.from(derivedKey.slice(16, 32)), ciphertext]));\n        if (mac.toString('hex') !== json.crypto.mac) {\n            throw new Error('Key derivation failed - possibly wrong passphrase');\n        }\n        const decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n        const seed = runCipherBuffer(decipher, ciphertext);\n        return new Wallet(seed);\n    }\n    /*\n     * Import an Ethereum Pre Sale wallet.\n     * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py\n     * JSON fields: encseed, ethaddr, btcaddr, email\n     *\n     * @param input A JSON serialized string, or an object representing EthSale Keystore.\n     * @param password The keystore password.\n     */\n    static fromEthSale(input, password) {\n        const json = typeof input === 'object' ? input : JSON.parse(input);\n        const encseed = Buffer.from(json.encseed, 'hex');\n        // key derivation\n        const derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);\n        // seed decoding (IV is first 16 bytes)\n        // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally\n        //       see also http://stackoverflow.com/a/31614770/4964819\n        const decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));\n        const seed = runCipherBuffer(decipher, encseed.slice(16));\n        const wallet = new Wallet((0, ethereumjs_util_1.keccak256)(seed));\n        if (wallet.getAddress().toString('hex') !== json.ethaddr) {\n            throw new Error('Decoded key mismatch - possibly wrong passphrase');\n        }\n        return wallet;\n    }\n    // private getters\n    /**\n     * Returns the wallet's public key.\n     */\n    get pubKey() {\n        if (!keyExists(this.publicKey)) {\n            this.publicKey = (0, ethereumjs_util_1.privateToPublic)(this.privateKey);\n        }\n        return this.publicKey;\n    }\n    /**\n     * Returns the wallet's private key.\n     */\n    get privKey() {\n        if (!keyExists(this.privateKey)) {\n            throw new Error('This is a public key only wallet');\n        }\n        return this.privateKey;\n    }\n    // public instance methods\n    /**\n     * Returns the wallet's private key.\n     *\n     */\n    // tslint:disable-next-line\n    getPrivateKey() {\n        return this.privKey;\n    }\n    getPrivateKeyString() {\n        return (0, ethereumjs_util_1.bufferToHex)(this.privKey);\n    }\n    /**\n     * Returns the wallet's public key.\n     */\n    // tslint:disable-next-line\n    getPublicKey() {\n        return this.pubKey;\n    }\n    /**\n     * Returns the wallet's public key as a \"0x\" prefixed hex string\n     */\n    getPublicKeyString() {\n        return (0, ethereumjs_util_1.bufferToHex)(this.getPublicKey());\n    }\n    /**\n     * Returns the wallet's address.\n     */\n    getAddress() {\n        return (0, ethereumjs_util_1.publicToAddress)(this.pubKey);\n    }\n    /**\n     * Returns the wallet's address as a \"0x\" prefixed hex string\n     */\n    getAddressString() {\n        return (0, ethereumjs_util_1.bufferToHex)(this.getAddress());\n    }\n    /**\n     * Returns the wallet's private key as a \"0x\" prefixed hex string checksummed\n     * according to [EIP 55](https://github.com/ethereum/EIPs/issues/55).\n     */\n    getChecksumAddressString() {\n        return (0, ethereumjs_util_1.toChecksumAddress)(this.getAddressString());\n    }\n    /**\n     * Returns an Etherem Version 3 Keystore Format object representing the wallet\n     *\n     * @param password The password used to encrypt the Keystore.\n     * @param opts The options for the keystore. See [its spec](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) for more info.\n     */\n    async toV3(password, opts) {\n        if (!keyExists(this.privateKey)) {\n            throw new Error('This is a public key only wallet');\n        }\n        const v3Params = mergeToV3ParamsWithDefaults(opts);\n        let kdfParams;\n        let derivedKey;\n        switch (v3Params.kdf) {\n            case \"pbkdf2\" /* PBKDF */:\n                kdfParams = kdfParamsForPBKDF(v3Params);\n                derivedKey = crypto.pbkdf2Sync(Buffer.from(password), kdfParams.salt, kdfParams.c, kdfParams.dklen, 'sha256');\n                break;\n            case \"scrypt\" /* Scrypt */:\n                kdfParams = kdfParamsForScrypt(v3Params);\n                // FIXME: support progress reporting callback\n                derivedKey = await (0, scrypt_js_1.scrypt)(Buffer.from(password), kdfParams.salt, kdfParams.n, kdfParams.r, kdfParams.p, kdfParams.dklen);\n                break;\n            default:\n                throw new Error('Unsupported kdf');\n        }\n        const cipher = crypto.createCipheriv(v3Params.cipher, derivedKey.slice(0, 16), v3Params.iv);\n        if (!cipher) {\n            throw new Error('Unsupported cipher');\n        }\n        const ciphertext = runCipherBuffer(cipher, this.privKey);\n        const mac = (0, ethereumjs_util_1.keccak256)(Buffer.concat([Buffer.from(derivedKey.slice(16, 32)), Buffer.from(ciphertext)]));\n        return {\n            version: 3,\n            id: uuidv4({ random: v3Params.uuid }),\n            // @ts-ignore - the official V3 keystore spec omits the address key\n            address: this.getAddress().toString('hex'),\n            crypto: {\n                ciphertext: ciphertext.toString('hex'),\n                cipherparams: { iv: v3Params.iv.toString('hex') },\n                cipher: v3Params.cipher,\n                kdf: v3Params.kdf,\n                kdfparams: Object.assign(Object.assign({}, kdfParams), { salt: kdfParams.salt.toString('hex') }),\n                mac: mac.toString('hex'),\n            },\n        };\n    }\n    /**\n     * Return the suggested filename for V3 keystores.\n     */\n    getV3Filename(timestamp) {\n        /*\n         * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting\n         * is a pain in Javascript, everbody knows that. We could use moment.js,\n         * but decide to do it manually in order to save space.\n         *\n         * toJSON() returns a pretty close version, so let's use it. It is not UTC though,\n         * but does it really matter?\n         *\n         * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819\n         *\n         */\n        const ts = timestamp ? new Date(timestamp) : new Date();\n        return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');\n    }\n    async toV3String(password, opts) {\n        return JSON.stringify(await this.toV3(password, opts));\n    }\n}\nexports[\"default\"] = Wallet;\n// helpers\nfunction runCipherBuffer(cipher, data) {\n    return Buffer.concat([cipher.update(data), cipher.final()]);\n}\nfunction keyExists(k) {\n    return k !== undefined && k !== null;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsYUFBYTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQywyRUFBaUI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsMkRBQVc7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLHlDQUF3QyxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUM1SCxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBYztBQUN6Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDdEksa0JBQWtCLG1CQUFPLENBQUMsMERBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOERBQWE7QUFDekMsZUFBZSx3RkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLG1CQUFtQixRQUFRO0FBQ3hFO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQSxtQ0FBbUMsVUFBVSxtQkFBbUIsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEUsK0RBQStELFFBQVE7QUFDdkUsbUNBQW1DLFVBQVUsc0JBQXNCLFlBQVksMkJBQTJCLGFBQWE7QUFDdkg7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLG1CQUFtQixRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0Isc0NBQXNDO0FBQy9HO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb3hpbWEvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC9pbmRleC5qcz8xMDMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRoaXJkcGFydHkgPSBleHBvcnRzLmhka2V5ID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3Qgc2NyeXB0X2pzXzEgPSByZXF1aXJlKFwic2NyeXB0LWpzXCIpO1xudmFyIGhka2V5XzEgPSByZXF1aXJlKFwiLi9oZGtleVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhka2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoaGRrZXlfMSkuZGVmYXVsdDsgfSB9KTtcbnZhciB0aGlyZHBhcnR5XzEgPSByZXF1aXJlKFwiLi90aGlyZHBhcnR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGhpcmRwYXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19pbXBvcnREZWZhdWx0KHRoaXJkcGFydHlfMSkuZGVmYXVsdDsgfSB9KTtcbmNvbnN0IGJzNThjaGVjayA9IHJlcXVpcmUoJ2JzNThjaGVjaycpO1xuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xuY29uc3QgdXVpZHY0ID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuZnVuY3Rpb24gdmFsaWRhdGVIZXhTdHJpbmcocGFyYW1OYW1lLCBzdHIsIGxlbmd0aCkge1xuICAgIGlmIChzdHIudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgICB9XG4gICAgaWYgKCFzdHIgJiYgIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICUgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbGVuZ3RoIGFyZ3VtZW50LCBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBzdHIubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7cGFyYW1OYW1lfSwgc3RyaW5nIG11c3QgYmUgJHtsZW5ndGh9IGhleCBjaGFyYWN0ZXJzYCk7XG4gICAgfVxuICAgIGlmICghL14oWzAtOWEtZl17Mn0pKyQvaS50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgaG93TWFueSA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gbGVuZ3RoIDogJ2VtcHR5IG9yIGEgbm9uLXplcm8gZXZlbiBudW1iZXIgb2YnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHtwYXJhbU5hbWV9LCBzdHJpbmcgbXVzdCBiZSAke2hvd01hbnl9IGhleCBjaGFyYWN0ZXJzYCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJ1ZmZlcihwYXJhbU5hbWUsIGJ1ZmYsIGxlbmd0aCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmYpKSB7XG4gICAgICAgIGNvbnN0IGhvd01hbnlIZXggPSB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyA/IGAke2xlbmd0aCAqIDJ9YCA6ICdlbXB0eSBvciBhIG5vbi16ZXJvIGV2ZW4gbnVtYmVyIG9mJztcbiAgICAgICAgY29uc3QgaG93TWFueUJ5dGVzID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBgICgke2xlbmd0aH0gYnl0ZXMpYCA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHtwYXJhbU5hbWV9LCBtdXN0IGJlIGEgc3RyaW5nICgke2hvd01hbnlIZXh9IGhleCBjaGFyYWN0ZXJzKSBvciBidWZmZXIke2hvd01hbnlCeXRlc31gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGJ1ZmYubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7cGFyYW1OYW1lfSwgYnVmZmVyIG11c3QgYmUgJHtsZW5ndGh9IGJ5dGVzYCk7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuZnVuY3Rpb24gbWVyZ2VUb1YzUGFyYW1zV2l0aERlZmF1bHRzKHBhcmFtcykge1xuICAgIGNvbnN0IHYzRGVmYXVsdHMgPSB7XG4gICAgICAgIGNpcGhlcjogJ2Flcy0xMjgtY3RyJyxcbiAgICAgICAga2RmOiAnc2NyeXB0JyxcbiAgICAgICAgc2FsdDogcmFuZG9tQnl0ZXMoMzIpLFxuICAgICAgICBpdjogcmFuZG9tQnl0ZXMoMTYpLFxuICAgICAgICB1dWlkOiByYW5kb21CeXRlcygxNiksXG4gICAgICAgIGRrbGVuOiAzMixcbiAgICAgICAgYzogMjYyMTQ0LFxuICAgICAgICBuOiAyNjIxNDQsXG4gICAgICAgIHI6IDgsXG4gICAgICAgIHA6IDEsXG4gICAgfTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICByZXR1cm4gdjNEZWZhdWx0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuc2FsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyYW1zLnNhbHQgPSBCdWZmZXIuZnJvbSh2YWxpZGF0ZUhleFN0cmluZygnc2FsdCcsIHBhcmFtcy5zYWx0KSwgJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5pdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyYW1zLml2ID0gQnVmZmVyLmZyb20odmFsaWRhdGVIZXhTdHJpbmcoJ2l2JywgcGFyYW1zLml2LCAzMiksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMudXVpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyYW1zLnV1aWQgPSBCdWZmZXIuZnJvbSh2YWxpZGF0ZUhleFN0cmluZygndXVpZCcsIHBhcmFtcy51dWlkLCAzMiksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5zYWx0KSB7XG4gICAgICAgIHZhbGlkYXRlQnVmZmVyKCdzYWx0JywgcGFyYW1zLnNhbHQpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLml2KSB7XG4gICAgICAgIHZhbGlkYXRlQnVmZmVyKCdpdicsIHBhcmFtcy5pdiwgMTYpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnV1aWQpIHtcbiAgICAgICAgdmFsaWRhdGVCdWZmZXIoJ3V1aWQnLCBwYXJhbXMudXVpZCwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2M0RlZmF1bHRzKSwgcGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGtkZlBhcmFtc0ZvclBCS0RGKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBka2xlbjogb3B0cy5ka2xlbixcbiAgICAgICAgc2FsdDogb3B0cy5zYWx0LFxuICAgICAgICBjOiBvcHRzLmMsXG4gICAgICAgIHByZjogJ2htYWMtc2hhMjU2JyxcbiAgICB9O1xufVxuZnVuY3Rpb24ga2RmUGFyYW1zRm9yU2NyeXB0KG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBka2xlbjogb3B0cy5ka2xlbixcbiAgICAgICAgc2FsdDogb3B0cy5zYWx0LFxuICAgICAgICBuOiBvcHRzLm4sXG4gICAgICAgIHI6IG9wdHMucixcbiAgICAgICAgcDogb3B0cy5wLFxuICAgIH07XG59XG4vLyB3YWxsZXQgaW1wbGVtZW50YXRpb25cbmNsYXNzIFdhbGxldCB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSwgcHVibGljS2V5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiBwdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN1cHBseSBib3RoIGEgcHJpdmF0ZSBhbmQgYSBwdWJsaWMga2V5IHRvIHRoZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcml2YXRlS2V5ICYmICEoMCwgZXRoZXJldW1qc191dGlsXzEuaXNWYWxpZFByaXZhdGUpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IGRvZXMgbm90IHNhdGlzZnkgdGhlIGN1cnZlIHJlcXVpcmVtZW50cyAoaWUuIGl0IGlzIGludmFsaWQpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YmxpY0tleSAmJiAhKDAsIGV0aGVyZXVtanNfdXRpbF8xLmlzVmFsaWRQdWJsaWMpKHB1YmxpY0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UgYmFzZWQgb24gYSBuZXcgcmFuZG9tIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpY2FwRGlyZWN0IHNldHRpbmcgdGhpcyB0byBgdHJ1ZWAgd2lsbCBnZW5lcmF0ZSBhbiBhZGRyZXNzIHN1aXRhYmxlIGZvciB0aGUgYElDQVAgRGlyZWN0IG1vZGVgXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlKGljYXBEaXJlY3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoaWNhcERpcmVjdCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKCcwODhmOTI0ZWVjZWVkYTdmZTkyZTFmNWIwZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgICAgICAgICAgIGlmIChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oKDAsIGV0aGVyZXVtanNfdXRpbF8xLnByaXZhdGVUb0FkZHJlc3MpKHByaXZhdGVLZXkpKS5sdGUobWF4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChyYW5kb21CeXRlcygzMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSB3aGVyZSB0aGUgYWRkcmVzcyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBzdXBwbGllZCBwYXR0ZXJuICgqKnRoaXMgd2lsbCBiZSB2ZXJ5IHNsb3cqKilcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVWYW5pdHlBZGRyZXNzKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCEocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5wcml2YXRlVG9BZGRyZXNzKShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoYWRkcmVzcy50b1N0cmluZygnaGV4JykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGJhc2VkIG9uIGEgcHVibGljIGtleSAoY2VydGFpbiBtZXRob2RzIHdpbGwgbm90IGJlIGF2YWlsYWJsZSlcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG9ubHkgYWNjZXB0cyB1bmNvbXByZXNzZWQgRXRoZXJldW0tc3R5bGUgcHVibGljIGtleXMsIHVubGVzc1xuICAgICAqIHRoZSBgbm9uU3RyaWN0YCBmbGFnIGlzIHNldCB0byB0cnVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHVibGljS2V5KHB1YmxpY0tleSwgbm9uU3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG5vblN0cmljdCkge1xuICAgICAgICAgICAgcHVibGljS2V5ID0gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmltcG9ydFB1YmxpYykocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh1bmRlZmluZWQsIHB1YmxpY0tleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBiYXNlZCBvbiBhIEJJUDMyIGV4dGVuZGVkIHB1YmxpYyBrZXkgKHhwdWIpXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FeHRlbmRlZFB1YmxpY0tleShleHRlbmRlZFB1YmxpY0tleSkge1xuICAgICAgICBpZiAoZXh0ZW5kZWRQdWJsaWNLZXkuc2xpY2UoMCwgNCkgIT09ICd4cHViJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gZXh0ZW5kZWQgcHVibGljIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGJzNThjaGVjay5kZWNvZGUoZXh0ZW5kZWRQdWJsaWNLZXkpLnNsaWNlKDQ1KTtcbiAgICAgICAgLy8gQ29udmVydCB0byBhbiBFdGhlcmV1bSBwdWJsaWMga2V5XG4gICAgICAgIHJldHVybiBXYWxsZXQuZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UgYmFzZWQgb24gYSByYXcgcHJpdmF0ZSBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFdhbGxldChwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGJhc2VkIG9uIGEgQklQMzIgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgKHhwcnYpXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FeHRlbmRlZFByaXZhdGVLZXkoZXh0ZW5kZWRQcml2YXRlS2V5KSB7XG4gICAgICAgIGlmIChleHRlbmRlZFByaXZhdGVLZXkuc2xpY2UoMCwgNCkgIT09ICd4cHJ2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0bXAgPSBiczU4Y2hlY2suZGVjb2RlKGV4dGVuZGVkUHJpdmF0ZUtleSk7XG4gICAgICAgIGlmICh0bXBbNDVdICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXh0ZW5kZWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV2FsbGV0LmZyb21Qcml2YXRlS2V5KHRtcC5zbGljZSg0NikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgYSB3YWxsZXQgKFZlcnNpb24gMSBvZiB0aGUgRXRoZXJldW0gd2FsbGV0IGZvcm1hdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBKU09OIHNlcmlhbGl6ZWQgc3RyaW5nLCBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIFYxIEtleXN0b3JlLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUga2V5c3RvcmUgcGFzc3dvcmQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21WMShpbnB1dCwgcGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoanNvbi5WZXJzaW9uICE9PSAnMScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgVjEgV2FsbGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uQ3J5cHRvLktleUhlYWRlci5LZGYgIT09ICdzY3J5cHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSBkZXJpdmF0aW9uIHNjaGVtZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtkZnBhcmFtcyA9IGpzb24uQ3J5cHRvLktleUhlYWRlci5LZGZQYXJhbXM7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBhd2FpdCAoMCwgc2NyeXB0X2pzXzEuc2NyeXB0KShCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGpzb24uQ3J5cHRvLlNhbHQsICdoZXgnKSwga2RmcGFyYW1zLk4sIGtkZnBhcmFtcy5SLCBrZGZwYXJhbXMuUCwga2RmcGFyYW1zLkRrTGVuKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGpzb24uQ3J5cHRvLkNpcGhlclRleHQsICdoZXgnKTtcbiAgICAgICAgY29uc3QgbWFjID0gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhazI1NikoQnVmZmVyLmNvbmNhdChbZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpO1xuICAgICAgICBpZiAobWFjLnRvU3RyaW5nKCdoZXgnKSAhPT0ganNvbi5DcnlwdG8uTUFDKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBkZXJpdmF0aW9uIGZhaWxlZCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMTI4LWNiYycsICgwLCBldGhlcmV1bWpzX3V0aWxfMS5rZWNjYWsyNTYpKGRlcml2ZWRLZXkuc2xpY2UoMCwgMTYpKS5zbGljZSgwLCAxNiksIEJ1ZmZlci5mcm9tKGpzb24uQ3J5cHRvLklWLCAnaGV4JykpO1xuICAgICAgICBjb25zdCBzZWVkID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBjaXBoZXJ0ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQoc2VlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydCBhIHdhbGxldCAoVmVyc2lvbiAzIG9mIHRoZSBFdGhlcmV1bSB3YWxsZXQgZm9ybWF0KS4gU2V0IGBub25TdHJpY3RgIHRydWUgdG8gYWNjZXB0IGZpbGVzIHdpdGggbWl4ZWQtY2Fwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBBIEpTT04gc2VyaWFsaXplZCBzdHJpbmcsIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgVjMgS2V5c3RvcmUuXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBrZXlzdG9yZSBwYXNzd29yZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVYzKGlucHV0LCBwYXNzd29yZCwgbm9uU3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2Uobm9uU3RyaWN0ID8gaW5wdXQudG9Mb3dlckNhc2UoKSA6IGlucHV0KTtcbiAgICAgICAgaWYgKGpzb24udmVyc2lvbiAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBWMyB3YWxsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVyaXZlZEtleSwga2RmcGFyYW1zO1xuICAgICAgICBpZiAoanNvbi5jcnlwdG8ua2RmID09PSAnc2NyeXB0Jykge1xuICAgICAgICAgICAga2RmcGFyYW1zID0ganNvbi5jcnlwdG8ua2RmcGFyYW1zO1xuICAgICAgICAgICAgLy8gRklYTUU6IHN1cHBvcnQgcHJvZ3Jlc3MgcmVwb3J0aW5nIGNhbGxiYWNrXG4gICAgICAgICAgICBkZXJpdmVkS2V5ID0gYXdhaXQgKDAsIHNjcnlwdF9qc18xLnNjcnlwdCkoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShrZGZwYXJhbXMuc2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMubiwga2RmcGFyYW1zLnIsIGtkZnBhcmFtcy5wLCBrZGZwYXJhbXMuZGtsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24uY3J5cHRvLmtkZiA9PT0gJ3Bia2RmMicpIHtcbiAgICAgICAgICAgIGtkZnBhcmFtcyA9IGpzb24uY3J5cHRvLmtkZnBhcmFtcztcbiAgICAgICAgICAgIGlmIChrZGZwYXJhbXMucHJmICE9PSAnaG1hYy1zaGEyNTYnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXJzIHRvIFBCS0RGMicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oa2RmcGFyYW1zLnNhbHQsICdoZXgnKSwga2RmcGFyYW1zLmMsIGtkZnBhcmFtcy5ka2xlbiwgJ3NoYTI1NicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBzY2hlbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oanNvbi5jcnlwdG8uY2lwaGVydGV4dCwgJ2hleCcpO1xuICAgICAgICBjb25zdCBtYWMgPSAoMCwgZXRoZXJldW1qc191dGlsXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShkZXJpdmVkS2V5LnNsaWNlKDE2LCAzMikpLCBjaXBoZXJ0ZXh0XSkpO1xuICAgICAgICBpZiAobWFjLnRvU3RyaW5nKCdoZXgnKSAhPT0ganNvbi5jcnlwdG8ubWFjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBkZXJpdmF0aW9uIGZhaWxlZCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGpzb24uY3J5cHRvLmNpcGhlciwgZGVyaXZlZEtleS5zbGljZSgwLCAxNiksIEJ1ZmZlci5mcm9tKGpzb24uY3J5cHRvLmNpcGhlcnBhcmFtcy5pdiwgJ2hleCcpKTtcbiAgICAgICAgY29uc3Qgc2VlZCA9IHJ1bkNpcGhlckJ1ZmZlcihkZWNpcGhlciwgY2lwaGVydGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHNlZWQpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIEltcG9ydCBhbiBFdGhlcmV1bSBQcmUgU2FsZSB3YWxsZXQuXG4gICAgICogQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3B5ZXRoc2FsZXRvb2wvYmxvYi9tYXN0ZXIvcHlldGhzYWxldG9vbC5weVxuICAgICAqIEpTT04gZmllbGRzOiBlbmNzZWVkLCBldGhhZGRyLCBidGNhZGRyLCBlbWFpbFxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEEgSlNPTiBzZXJpYWxpemVkIHN0cmluZywgb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBFdGhTYWxlIEtleXN0b3JlLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUga2V5c3RvcmUgcGFzc3dvcmQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FdGhTYWxlKGlucHV0LCBwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBqc29uID0gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVuY3NlZWQgPSBCdWZmZXIuZnJvbShqc29uLmVuY3NlZWQsICdoZXgnKTtcbiAgICAgICAgLy8ga2V5IGRlcml2YXRpb25cbiAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBwYXNzd29yZCwgMjAwMCwgMzIsICdzaGEyNTYnKS5zbGljZSgwLCAxNik7XG4gICAgICAgIC8vIHNlZWQgZGVjb2RpbmcgKElWIGlzIGZpcnN0IDE2IGJ5dGVzKVxuICAgICAgICAvLyBOT1RFOiBjcnlwdG8gKGRlcml2ZWQgZnJvbSBvcGVuc3NsKSB3aGVuIHVzZWQgd2l0aCBhZXMtKi1jYmMgd2lsbCBoYW5kbGUgUEtDUyM3IHBhZGRpbmcgaW50ZXJuYWxseVxuICAgICAgICAvLyAgICAgICBzZWUgYWxzbyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTYxNDc3MC80OTY0ODE5XG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0xMjgtY2JjJywgZGVyaXZlZEtleSwgZW5jc2VlZC5zbGljZSgwLCAxNikpO1xuICAgICAgICBjb25zdCBzZWVkID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBlbmNzZWVkLnNsaWNlKDE2KSk7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQoKDAsIGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhazI1Nikoc2VlZCkpO1xuICAgICAgICBpZiAod2FsbGV0LmdldEFkZHJlc3MoKS50b1N0cmluZygnaGV4JykgIT09IGpzb24uZXRoYWRkcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIGtleSBtaXNtYXRjaCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvLyBwcml2YXRlIGdldHRlcnNcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIGdldCBwdWJLZXkoKSB7XG4gICAgICAgIGlmICgha2V5RXhpc3RzKHRoaXMucHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSAoMCwgZXRoZXJldW1qc191dGlsXzEucHJpdmF0ZVRvUHVibGljKSh0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FsbGV0J3MgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZLZXkoKSB7XG4gICAgICAgIGlmICgha2V5RXhpc3RzKHRoaXMucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyBhIHB1YmxpYyBrZXkgb25seSB3YWxsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlS2V5O1xuICAgIH1cbiAgICAvLyBwdWJsaWMgaW5zdGFuY2UgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCdzIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgZ2V0UHJpdmF0ZUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdktleTtcbiAgICB9XG4gICAgZ2V0UHJpdmF0ZUtleVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgwLCBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleCkodGhpcy5wcml2S2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FsbGV0J3MgcHVibGljIGtleS5cbiAgICAgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YktleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FsbGV0J3MgcHVibGljIGtleSBhcyBhIFwiMHhcIiBwcmVmaXhlZCBoZXggc3RyaW5nXG4gICAgICovXG4gICAgZ2V0UHVibGljS2V5U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KSh0aGlzLmdldFB1YmxpY0tleSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FsbGV0J3MgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykodGhpcy5wdWJLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBhZGRyZXNzIGFzIGEgXCIweFwiIHByZWZpeGVkIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KSh0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCdzIHByaXZhdGUga2V5IGFzIGEgXCIweFwiIHByZWZpeGVkIGhleCBzdHJpbmcgY2hlY2tzdW1tZWRcbiAgICAgKiBhY2NvcmRpbmcgdG8gW0VJUCA1NV0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvaXNzdWVzLzU1KS5cbiAgICAgKi9cbiAgICBnZXRDaGVja3N1bUFkZHJlc3NTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXRoZXJldW1qc191dGlsXzEudG9DaGVja3N1bUFkZHJlc3MpKHRoaXMuZ2V0QWRkcmVzc1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBFdGhlcmVtIFZlcnNpb24gMyBLZXlzdG9yZSBGb3JtYXQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgd2FsbGV0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHVzZWQgdG8gZW5jcnlwdCB0aGUgS2V5c3RvcmUuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgZm9yIHRoZSBrZXlzdG9yZS4gU2VlIFtpdHMgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb24pIGZvciBtb3JlIGluZm8uXG4gICAgICovXG4gICAgYXN5bmMgdG9WMyhwYXNzd29yZCwgb3B0cykge1xuICAgICAgICBpZiAoIWtleUV4aXN0cyh0aGlzLnByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgYSBwdWJsaWMga2V5IG9ubHkgd2FsbGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdjNQYXJhbXMgPSBtZXJnZVRvVjNQYXJhbXNXaXRoRGVmYXVsdHMob3B0cyk7XG4gICAgICAgIGxldCBrZGZQYXJhbXM7XG4gICAgICAgIGxldCBkZXJpdmVkS2V5O1xuICAgICAgICBzd2l0Y2ggKHYzUGFyYW1zLmtkZikge1xuICAgICAgICAgICAgY2FzZSBcInBia2RmMlwiIC8qIFBCS0RGICovOlxuICAgICAgICAgICAgICAgIGtkZlBhcmFtcyA9IGtkZlBhcmFtc0ZvclBCS0RGKHYzUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBrZGZQYXJhbXMuc2FsdCwga2RmUGFyYW1zLmMsIGtkZlBhcmFtcy5ka2xlbiwgJ3NoYTI1NicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjcnlwdFwiIC8qIFNjcnlwdCAqLzpcbiAgICAgICAgICAgICAgICBrZGZQYXJhbXMgPSBrZGZQYXJhbXNGb3JTY3J5cHQodjNQYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IHByb2dyZXNzIHJlcG9ydGluZyBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkgPSBhd2FpdCAoMCwgc2NyeXB0X2pzXzEuc2NyeXB0KShCdWZmZXIuZnJvbShwYXNzd29yZCksIGtkZlBhcmFtcy5zYWx0LCBrZGZQYXJhbXMubiwga2RmUGFyYW1zLnIsIGtkZlBhcmFtcy5wLCBrZGZQYXJhbXMuZGtsZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtkZicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdih2M1BhcmFtcy5jaXBoZXIsIGRlcml2ZWRLZXkuc2xpY2UoMCwgMTYpLCB2M1BhcmFtcy5pdik7XG4gICAgICAgIGlmICghY2lwaGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNpcGhlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBydW5DaXBoZXJCdWZmZXIoY2lwaGVyLCB0aGlzLnByaXZLZXkpO1xuICAgICAgICBjb25zdCBtYWMgPSAoMCwgZXRoZXJldW1qc191dGlsXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShkZXJpdmVkS2V5LnNsaWNlKDE2LCAzMikpLCBCdWZmZXIuZnJvbShjaXBoZXJ0ZXh0KV0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgICAgICBpZDogdXVpZHY0KHsgcmFuZG9tOiB2M1BhcmFtcy51dWlkIH0pLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHRoZSBvZmZpY2lhbCBWMyBrZXlzdG9yZSBzcGVjIG9taXRzIHRoZSBhZGRyZXNzIGtleVxuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5nZXRBZGRyZXNzKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgY3J5cHRvOiB7XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dC50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7IGl2OiB2M1BhcmFtcy5pdi50b1N0cmluZygnaGV4JykgfSxcbiAgICAgICAgICAgICAgICBjaXBoZXI6IHYzUGFyYW1zLmNpcGhlcixcbiAgICAgICAgICAgICAgICBrZGY6IHYzUGFyYW1zLmtkZixcbiAgICAgICAgICAgICAgICBrZGZwYXJhbXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwga2RmUGFyYW1zKSwgeyBzYWx0OiBrZGZQYXJhbXMuc2FsdC50b1N0cmluZygnaGV4JykgfSksXG4gICAgICAgICAgICAgICAgbWFjOiBtYWMudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdWdnZXN0ZWQgZmlsZW5hbWUgZm9yIFYzIGtleXN0b3Jlcy5cbiAgICAgKi9cbiAgICBnZXRWM0ZpbGVuYW1lKHRpbWVzdGFtcCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSB3YW50IGEgdGltZXN0YW1wIGxpa2UgMjAxNi0wMy0xNVQxNy0xMS0zMy4wMDc1OTgyODhaLiBEYXRlIGZvcm1hdHRpbmdcbiAgICAgICAgICogaXMgYSBwYWluIGluIEphdmFzY3JpcHQsIGV2ZXJib2R5IGtub3dzIHRoYXQuIFdlIGNvdWxkIHVzZSBtb21lbnQuanMsXG4gICAgICAgICAqIGJ1dCBkZWNpZGUgdG8gZG8gaXQgbWFudWFsbHkgaW4gb3JkZXIgdG8gc2F2ZSBzcGFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogdG9KU09OKCkgcmV0dXJucyBhIHByZXR0eSBjbG9zZSB2ZXJzaW9uLCBzbyBsZXQncyB1c2UgaXQuIEl0IGlzIG5vdCBVVEMgdGhvdWdoLFxuICAgICAgICAgKiBidXQgZG9lcyBpdCByZWFsbHkgbWF0dGVyP1xuICAgICAgICAgKlxuICAgICAgICAgKiBBbHRlcm5hdGl2ZSBtYW51YWwgd2F5IHdpdGggcGFkZGluZyBhbmQgRGF0ZSBmaWVsZHM6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcyNDQyODgvNDk2NDgxOVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdHMgPSB0aW1lc3RhbXAgPyBuZXcgRGF0ZSh0aW1lc3RhbXApIDogbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIFsnVVRDLS0nLCB0cy50b0pTT04oKS5yZXBsYWNlKC86L2csICctJyksICctLScsIHRoaXMuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignJyk7XG4gICAgfVxuICAgIGFzeW5jIHRvVjNTdHJpbmcocGFzc3dvcmQsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IHRoaXMudG9WMyhwYXNzd29yZCwgb3B0cykpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFdhbGxldDtcbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHJ1bkNpcGhlckJ1ZmZlcihjaXBoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhKSwgY2lwaGVyLmZpbmFsKCldKTtcbn1cbmZ1bmN0aW9uIGtleUV4aXN0cyhrKSB7XG4gICAgcmV0dXJuIGsgIT09IHVuZGVmaW5lZCAmJiBrICE9PSBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-wallet/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-wallet/dist/thirdparty.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethereumjs-wallet/dist/thirdparty.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromQuorumWallet = exports.fromKryptoKit = exports.fromEtherCamp = exports.fromEtherWallet = void 0;\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ \"(ssr)/./node_modules/ethereumjs-util/dist/index.js\");\nconst scrypt_js_1 = __webpack_require__(/*! scrypt-js */ \"(ssr)/./node_modules/scrypt-js/scrypt.js\");\nconst index_1 = __importDefault(__webpack_require__(/*! ./index */ \"(ssr)/./node_modules/ethereumjs-wallet/dist/index.js\"));\nconst utf8 = __webpack_require__(/*! utf8 */ \"(ssr)/./node_modules/utf8/utf8.js\");\nconst aesjs = __webpack_require__(/*! aes-js */ \"(ssr)/./node_modules/aes-js/index.js\");\nfunction runCipherBuffer(cipher, data) {\n    return Buffer.concat([cipher.update(data), cipher.final()]);\n}\nconst evpKdfDefaults = {\n    count: 1,\n    keysize: 16,\n    ivsize: 16,\n    digest: 'md5',\n};\nfunction mergeEvpKdfOptsWithDefaults(opts) {\n    if (!opts) {\n        return evpKdfDefaults;\n    }\n    return {\n        count: opts.count || evpKdfDefaults.count,\n        keysize: opts.keysize || evpKdfDefaults.keysize,\n        ivsize: opts.ivsize || evpKdfDefaults.ivsize,\n        digest: opts.digest || evpKdfDefaults.digest,\n    };\n}\n/*\n * opts:\n * - digest - digest algorithm, defaults to md5\n * - count - hash iterations\n * - keysize - desired key size\n * - ivsize - desired IV size\n *\n * Algorithm form https://www.openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html\n *\n * FIXME: not optimised at all\n */\nfunction evp_kdf(data, salt, opts) {\n    const params = mergeEvpKdfOptsWithDefaults(opts);\n    // A single EVP iteration, returns `D_i`, where block equlas to `D_(i-1)`\n    function iter(block) {\n        let hash = crypto.createHash(params.digest);\n        hash.update(block);\n        hash.update(data);\n        hash.update(salt);\n        block = hash.digest();\n        for (let i = 1, len = params.count; i < len; i++) {\n            hash = crypto.createHash(params.digest);\n            hash.update(block);\n            block = hash.digest();\n        }\n        return block;\n    }\n    const ret = [];\n    let i = 0;\n    while (Buffer.concat(ret).length < params.keysize + params.ivsize) {\n        ret[i] = iter(i === 0 ? Buffer.alloc(0) : ret[i - 1]);\n        i++;\n    }\n    const tmp = Buffer.concat(ret);\n    return {\n        key: tmp.slice(0, params.keysize),\n        iv: tmp.slice(params.keysize, params.keysize + params.ivsize),\n    };\n}\n// http://stackoverflow.com/questions/25288311/cryptojs-aes-pattern-always-ends-with\nfunction decodeCryptojsSalt(input) {\n    const ciphertext = Buffer.from(input, 'base64');\n    if (ciphertext.slice(0, 8).toString() === 'Salted__') {\n        return {\n            salt: ciphertext.slice(8, 16),\n            ciphertext: ciphertext.slice(16),\n        };\n    }\n    return { ciphertext };\n}\n/*\n * Third Party API: Import a wallet generated by EtherWallet\n * This wallet format is created by https://github.com/SilentCicero/ethereumjs-accounts\n * and used on https://www.myetherwallet.com/\n */\nfunction fromEtherWallet(input, password) {\n    const json = typeof input === 'object' ? input : JSON.parse(input);\n    let privateKey;\n    if (!json.locked) {\n        if (json.private.length !== 64) {\n            throw new Error('Invalid private key length');\n        }\n        privateKey = Buffer.from(json.private, 'hex');\n    }\n    else {\n        if (typeof password !== 'string') {\n            throw new Error('Password required');\n        }\n        if (password.length < 7) {\n            throw new Error('Password must be at least 7 characters');\n        }\n        // the \"encrypted\" version has the low 4 bytes\n        // of the hash of the address appended\n        const hash = json.encrypted ? json.private.slice(0, 128) : json.private;\n        // decode openssl ciphertext + salt encoding\n        const cipher = decodeCryptojsSalt(hash);\n        if (!cipher.salt) {\n            throw new Error('Unsupported EtherWallet key format');\n        }\n        // derive key/iv using OpenSSL EVP as implemented in CryptoJS\n        const evp = evp_kdf(Buffer.from(password), cipher.salt, { keysize: 32, ivsize: 16 });\n        const decipher = crypto.createDecipheriv('aes-256-cbc', evp.key, evp.iv);\n        privateKey = runCipherBuffer(decipher, Buffer.from(cipher.ciphertext));\n        // NOTE: yes, they've run it through UTF8\n        privateKey = Buffer.from(utf8.decode(privateKey.toString()), 'hex');\n    }\n    const wallet = new index_1.default(privateKey);\n    if (wallet.getAddressString() !== json.address) {\n        throw new Error('Invalid private key or address');\n    }\n    return wallet;\n}\nexports.fromEtherWallet = fromEtherWallet;\n/**\n * Third Party API: Import a brain wallet used by Ether.Camp\n */\nfunction fromEtherCamp(passphrase) {\n    return new index_1.default((0, ethereumjs_util_1.keccak256)(Buffer.from(passphrase)));\n}\nexports.fromEtherCamp = fromEtherCamp;\n/**\n * Third Party API: Import a wallet from a KryptoKit seed\n */\nasync function fromKryptoKit(entropy, password) {\n    function kryptoKitBrokenScryptSeed(buf) {\n        // js-scrypt calls `Buffer.from(String(salt), 'utf8')` on the seed even though it is a buffer\n        //\n        // The `buffer`` implementation used does the below transformation (doesn't matches the current version):\n        // https://github.com/feross/buffer/blob/67c61181b938b17d10dbfc0a545f713b8bd59de8/index.js\n        function decodeUtf8Char(str) {\n            try {\n                return decodeURIComponent(str);\n            }\n            catch (err) {\n                return String.fromCharCode(0xfffd); // UTF 8 invalid char\n            }\n        }\n        let res = '', tmp = '';\n        for (let i = 0; i < buf.length; i++) {\n            if (buf[i] <= 0x7f) {\n                res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);\n                tmp = '';\n            }\n            else {\n                tmp += '%' + buf[i].toString(16);\n            }\n        }\n        return Buffer.from(res + decodeUtf8Char(tmp));\n    }\n    if (entropy[0] === '#') {\n        entropy = entropy.slice(1);\n    }\n    const type = entropy[0];\n    entropy = entropy.slice(1);\n    let privateKey;\n    if (type === 'd') {\n        privateKey = (0, ethereumjs_util_1.sha256)((0, ethereumjs_util_1.toBuffer)(entropy));\n    }\n    else if (type === 'q') {\n        if (typeof password !== 'string') {\n            throw new Error('Password required');\n        }\n        const encryptedSeed = (0, ethereumjs_util_1.sha256)(Buffer.from(entropy.slice(0, 30)));\n        const checksum = entropy.slice(30, 46);\n        const salt = kryptoKitBrokenScryptSeed(encryptedSeed);\n        const aesKey = await (0, scrypt_js_1.scrypt)(Buffer.from(password, 'utf8'), salt, 16384, 8, 1, 32);\n        /* FIXME: try to use `crypto` instead of `aesjs`\n    \n        // NOTE: ECB doesn't use the IV, so it can be anything\n        var decipher = crypto.createDecipheriv(\"aes-256-ecb\", aesKey, Buffer.from(0))\n    \n        // FIXME: this is a clear abuse, but seems to match how ECB in aesjs works\n        privKey = Buffer.concat([\n          decipher.update(encryptedSeed).slice(0, 16),\n          decipher.update(encryptedSeed).slice(0, 16),\n        ])\n        */\n        const decipher = new aesjs.ModeOfOperation.ecb(aesKey);\n        /* decrypt returns an Uint8Array, perhaps there is a better way to concatenate */\n        privateKey = Buffer.concat([\n            Buffer.from(decipher.decrypt(encryptedSeed.slice(0, 16))),\n            Buffer.from(decipher.decrypt(encryptedSeed.slice(16, 32))),\n        ]);\n        if (checksum.length > 0) {\n            if (checksum !== (0, ethereumjs_util_1.sha256)((0, ethereumjs_util_1.sha256)(privateKey)).slice(0, 8).toString('hex')) {\n                throw new Error('Failed to decrypt input - possibly invalid passphrase');\n            }\n        }\n    }\n    else {\n        throw new Error('Unsupported or invalid entropy type');\n    }\n    return new index_1.default(privateKey);\n}\nexports.fromKryptoKit = fromKryptoKit;\n/**\n * Third Party API: Import a brain wallet used by Quorum Wallet\n */\nfunction fromQuorumWallet(passphrase, userid) {\n    if (passphrase.length < 10) {\n        throw new Error('Passphrase must be at least 10 characters');\n    }\n    if (userid.length < 10) {\n        throw new Error('User id must be at least 10 characters');\n    }\n    const merged = passphrase + userid;\n    const seed = crypto.pbkdf2Sync(merged, merged, 2000, 32, 'sha256');\n    return new index_1.default(seed);\n}\nexports.fromQuorumWallet = fromQuorumWallet;\nconst Thirdparty = {\n    fromEtherWallet,\n    fromEtherCamp,\n    fromKryptoKit,\n    fromQuorumWallet,\n};\nexports[\"default\"] = Thirdparty;\n//# sourceMappingURL=thirdparty.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC90aGlyZHBhcnR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUI7QUFDbEcsNEJBQTRCLG1CQUFPLENBQUMsc0JBQVE7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMsMkVBQWlCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLDJEQUFXO0FBQ3ZDLGdDQUFnQyxtQkFBTyxDQUFDLHFFQUFTO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQywrQ0FBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsb0RBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UseUJBQXlCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm94aW1hLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L2Rpc3QvdGhpcmRwYXJ0eS5qcz8zMmI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21RdW9ydW1XYWxsZXQgPSBleHBvcnRzLmZyb21LcnlwdG9LaXQgPSBleHBvcnRzLmZyb21FdGhlckNhbXAgPSBleHBvcnRzLmZyb21FdGhlcldhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IHNjcnlwdF9qc18xID0gcmVxdWlyZShcInNjcnlwdC1qc1wiKTtcbmNvbnN0IGluZGV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaW5kZXhcIikpO1xuY29uc3QgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcbmNvbnN0IGFlc2pzID0gcmVxdWlyZSgnYWVzLWpzJyk7XG5mdW5jdGlvbiBydW5DaXBoZXJCdWZmZXIoY2lwaGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUoZGF0YSksIGNpcGhlci5maW5hbCgpXSk7XG59XG5jb25zdCBldnBLZGZEZWZhdWx0cyA9IHtcbiAgICBjb3VudDogMSxcbiAgICBrZXlzaXplOiAxNixcbiAgICBpdnNpemU6IDE2LFxuICAgIGRpZ2VzdDogJ21kNScsXG59O1xuZnVuY3Rpb24gbWVyZ2VFdnBLZGZPcHRzV2l0aERlZmF1bHRzKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGV2cEtkZkRlZmF1bHRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb3VudDogb3B0cy5jb3VudCB8fCBldnBLZGZEZWZhdWx0cy5jb3VudCxcbiAgICAgICAga2V5c2l6ZTogb3B0cy5rZXlzaXplIHx8IGV2cEtkZkRlZmF1bHRzLmtleXNpemUsXG4gICAgICAgIGl2c2l6ZTogb3B0cy5pdnNpemUgfHwgZXZwS2RmRGVmYXVsdHMuaXZzaXplLFxuICAgICAgICBkaWdlc3Q6IG9wdHMuZGlnZXN0IHx8IGV2cEtkZkRlZmF1bHRzLmRpZ2VzdCxcbiAgICB9O1xufVxuLypcbiAqIG9wdHM6XG4gKiAtIGRpZ2VzdCAtIGRpZ2VzdCBhbGdvcml0aG0sIGRlZmF1bHRzIHRvIG1kNVxuICogLSBjb3VudCAtIGhhc2ggaXRlcmF0aW9uc1xuICogLSBrZXlzaXplIC0gZGVzaXJlZCBrZXkgc2l6ZVxuICogLSBpdnNpemUgLSBkZXNpcmVkIElWIHNpemVcbiAqXG4gKiBBbGdvcml0aG0gZm9ybSBodHRwczovL3d3dy5vcGVuc3NsLm9yZy9kb2NzL21hbm1hc3Rlci9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEZJWE1FOiBub3Qgb3B0aW1pc2VkIGF0IGFsbFxuICovXG5mdW5jdGlvbiBldnBfa2RmKGRhdGEsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBtZXJnZUV2cEtkZk9wdHNXaXRoRGVmYXVsdHMob3B0cyk7XG4gICAgLy8gQSBzaW5nbGUgRVZQIGl0ZXJhdGlvbiwgcmV0dXJucyBgRF9pYCwgd2hlcmUgYmxvY2sgZXF1bGFzIHRvIGBEXyhpLTEpYFxuICAgIGZ1bmN0aW9uIGl0ZXIoYmxvY2spIHtcbiAgICAgICAgbGV0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChwYXJhbXMuZGlnZXN0KTtcbiAgICAgICAgaGFzaC51cGRhdGUoYmxvY2spO1xuICAgICAgICBoYXNoLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgaGFzaC51cGRhdGUoc2FsdCk7XG4gICAgICAgIGJsb2NrID0gaGFzaC5kaWdlc3QoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHBhcmFtcy5jb3VudDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2gocGFyYW1zLmRpZ2VzdCk7XG4gICAgICAgICAgICBoYXNoLnVwZGF0ZShibG9jayk7XG4gICAgICAgICAgICBibG9jayA9IGhhc2guZGlnZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKEJ1ZmZlci5jb25jYXQocmV0KS5sZW5ndGggPCBwYXJhbXMua2V5c2l6ZSArIHBhcmFtcy5pdnNpemUpIHtcbiAgICAgICAgcmV0W2ldID0gaXRlcihpID09PSAwID8gQnVmZmVyLmFsbG9jKDApIDogcmV0W2kgLSAxXSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgY29uc3QgdG1wID0gQnVmZmVyLmNvbmNhdChyZXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogdG1wLnNsaWNlKDAsIHBhcmFtcy5rZXlzaXplKSxcbiAgICAgICAgaXY6IHRtcC5zbGljZShwYXJhbXMua2V5c2l6ZSwgcGFyYW1zLmtleXNpemUgKyBwYXJhbXMuaXZzaXplKSxcbiAgICB9O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTI4ODMxMS9jcnlwdG9qcy1hZXMtcGF0dGVybi1hbHdheXMtZW5kcy13aXRoXG5mdW5jdGlvbiBkZWNvZGVDcnlwdG9qc1NhbHQoaW5wdXQpIHtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oaW5wdXQsICdiYXNlNjQnKTtcbiAgICBpZiAoY2lwaGVydGV4dC5zbGljZSgwLCA4KS50b1N0cmluZygpID09PSAnU2FsdGVkX18nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYWx0OiBjaXBoZXJ0ZXh0LnNsaWNlKDgsIDE2KSxcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQuc2xpY2UoMTYpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjaXBoZXJ0ZXh0IH07XG59XG4vKlxuICogVGhpcmQgUGFydHkgQVBJOiBJbXBvcnQgYSB3YWxsZXQgZ2VuZXJhdGVkIGJ5IEV0aGVyV2FsbGV0XG4gKiBUaGlzIHdhbGxldCBmb3JtYXQgaXMgY3JlYXRlZCBieSBodHRwczovL2dpdGh1Yi5jb20vU2lsZW50Q2ljZXJvL2V0aGVyZXVtanMtYWNjb3VudHNcbiAqIGFuZCB1c2VkIG9uIGh0dHBzOi8vd3d3Lm15ZXRoZXJ3YWxsZXQuY29tL1xuICovXG5mdW5jdGlvbiBmcm9tRXRoZXJXYWxsZXQoaW5wdXQsIHBhc3N3b3JkKSB7XG4gICAgY29uc3QganNvbiA9IHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2UoaW5wdXQpO1xuICAgIGxldCBwcml2YXRlS2V5O1xuICAgIGlmICghanNvbi5sb2NrZWQpIHtcbiAgICAgICAgaWYgKGpzb24ucHJpdmF0ZS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXkgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKGpzb24ucHJpdmF0ZSwgJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDcgY2hhcmFjdGVycycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBcImVuY3J5cHRlZFwiIHZlcnNpb24gaGFzIHRoZSBsb3cgNCBieXRlc1xuICAgICAgICAvLyBvZiB0aGUgaGFzaCBvZiB0aGUgYWRkcmVzcyBhcHBlbmRlZFxuICAgICAgICBjb25zdCBoYXNoID0ganNvbi5lbmNyeXB0ZWQgPyBqc29uLnByaXZhdGUuc2xpY2UoMCwgMTI4KSA6IGpzb24ucHJpdmF0ZTtcbiAgICAgICAgLy8gZGVjb2RlIG9wZW5zc2wgY2lwaGVydGV4dCArIHNhbHQgZW5jb2RpbmdcbiAgICAgICAgY29uc3QgY2lwaGVyID0gZGVjb2RlQ3J5cHRvanNTYWx0KGhhc2gpO1xuICAgICAgICBpZiAoIWNpcGhlci5zYWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEV0aGVyV2FsbGV0IGtleSBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXJpdmUga2V5L2l2IHVzaW5nIE9wZW5TU0wgRVZQIGFzIGltcGxlbWVudGVkIGluIENyeXB0b0pTXG4gICAgICAgIGNvbnN0IGV2cCA9IGV2cF9rZGYoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBjaXBoZXIuc2FsdCwgeyBrZXlzaXplOiAzMiwgaXZzaXplOiAxNiB9KTtcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1jYmMnLCBldnAua2V5LCBldnAuaXYpO1xuICAgICAgICBwcml2YXRlS2V5ID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBCdWZmZXIuZnJvbShjaXBoZXIuY2lwaGVydGV4dCkpO1xuICAgICAgICAvLyBOT1RFOiB5ZXMsIHRoZXkndmUgcnVuIGl0IHRocm91Z2ggVVRGOFxuICAgICAgICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20odXRmOC5kZWNvZGUocHJpdmF0ZUtleS50b1N0cmluZygpKSwgJ2hleCcpO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXQgPSBuZXcgaW5kZXhfMS5kZWZhdWx0KHByaXZhdGVLZXkpO1xuICAgIGlmICh3YWxsZXQuZ2V0QWRkcmVzc1N0cmluZygpICE9PSBqc29uLmFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5IG9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHdhbGxldDtcbn1cbmV4cG9ydHMuZnJvbUV0aGVyV2FsbGV0ID0gZnJvbUV0aGVyV2FsbGV0O1xuLyoqXG4gKiBUaGlyZCBQYXJ0eSBBUEk6IEltcG9ydCBhIGJyYWluIHdhbGxldCB1c2VkIGJ5IEV0aGVyLkNhbXBcbiAqL1xuZnVuY3Rpb24gZnJvbUV0aGVyQ2FtcChwYXNzcGhyYXNlKSB7XG4gICAgcmV0dXJuIG5ldyBpbmRleF8xLmRlZmF1bHQoKDAsIGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhazI1NikoQnVmZmVyLmZyb20ocGFzc3BocmFzZSkpKTtcbn1cbmV4cG9ydHMuZnJvbUV0aGVyQ2FtcCA9IGZyb21FdGhlckNhbXA7XG4vKipcbiAqIFRoaXJkIFBhcnR5IEFQSTogSW1wb3J0IGEgd2FsbGV0IGZyb20gYSBLcnlwdG9LaXQgc2VlZFxuICovXG5hc3luYyBmdW5jdGlvbiBmcm9tS3J5cHRvS2l0KGVudHJvcHksIHBhc3N3b3JkKSB7XG4gICAgZnVuY3Rpb24ga3J5cHRvS2l0QnJva2VuU2NyeXB0U2VlZChidWYpIHtcbiAgICAgICAgLy8ganMtc2NyeXB0IGNhbGxzIGBCdWZmZXIuZnJvbShTdHJpbmcoc2FsdCksICd1dGY4JylgIG9uIHRoZSBzZWVkIGV2ZW4gdGhvdWdoIGl0IGlzIGEgYnVmZmVyXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBgYnVmZmVyYGAgaW1wbGVtZW50YXRpb24gdXNlZCBkb2VzIHRoZSBiZWxvdyB0cmFuc2Zvcm1hdGlvbiAoZG9lc24ndCBtYXRjaGVzIHRoZSBjdXJyZW50IHZlcnNpb24pOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY3YzYxMTgxYjkzOGIxN2QxMGRiZmMwYTU0NWY3MTNiOGJkNTlkZTgvaW5kZXguanNcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIoc3RyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpOyAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzID0gJycsIHRtcCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ1ZltpXSA8PSAweDdmKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzICsgZGVjb2RlVXRmOENoYXIodG1wKSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5WzBdID09PSAnIycpIHtcbiAgICAgICAgZW50cm9weSA9IGVudHJvcHkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBlbnRyb3B5WzBdO1xuICAgIGVudHJvcHkgPSBlbnRyb3B5LnNsaWNlKDEpO1xuICAgIGxldCBwcml2YXRlS2V5O1xuICAgIGlmICh0eXBlID09PSAnZCcpIHtcbiAgICAgICAgcHJpdmF0ZUtleSA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5zaGEyNTYpKCgwLCBldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcikoZW50cm9weSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAncScpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNyeXB0ZWRTZWVkID0gKDAsIGV0aGVyZXVtanNfdXRpbF8xLnNoYTI1NikoQnVmZmVyLmZyb20oZW50cm9weS5zbGljZSgwLCAzMCkpKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBlbnRyb3B5LnNsaWNlKDMwLCA0Nik7XG4gICAgICAgIGNvbnN0IHNhbHQgPSBrcnlwdG9LaXRCcm9rZW5TY3J5cHRTZWVkKGVuY3J5cHRlZFNlZWQpO1xuICAgICAgICBjb25zdCBhZXNLZXkgPSBhd2FpdCAoMCwgc2NyeXB0X2pzXzEuc2NyeXB0KShCdWZmZXIuZnJvbShwYXNzd29yZCwgJ3V0ZjgnKSwgc2FsdCwgMTYzODQsIDgsIDEsIDMyKTtcbiAgICAgICAgLyogRklYTUU6IHRyeSB0byB1c2UgYGNyeXB0b2AgaW5zdGVhZCBvZiBgYWVzanNgXG4gICAgXG4gICAgICAgIC8vIE5PVEU6IEVDQiBkb2Vzbid0IHVzZSB0aGUgSVYsIHNvIGl0IGNhbiBiZSBhbnl0aGluZ1xuICAgICAgICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtZWNiXCIsIGFlc0tleSwgQnVmZmVyLmZyb20oMCkpXG4gICAgXG4gICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgY2xlYXIgYWJ1c2UsIGJ1dCBzZWVtcyB0byBtYXRjaCBob3cgRUNCIGluIGFlc2pzIHdvcmtzXG4gICAgICAgIHByaXZLZXkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkU2VlZCkuc2xpY2UoMCwgMTYpLFxuICAgICAgICAgIGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWRTZWVkKS5zbGljZSgwLCAxNiksXG4gICAgICAgIF0pXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gbmV3IGFlc2pzLk1vZGVPZk9wZXJhdGlvbi5lY2IoYWVzS2V5KTtcbiAgICAgICAgLyogZGVjcnlwdCByZXR1cm5zIGFuIFVpbnQ4QXJyYXksIHBlcmhhcHMgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGNvbmNhdGVuYXRlICovXG4gICAgICAgIHByaXZhdGVLZXkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkU2VlZC5zbGljZSgwLCAxNikpKSxcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkU2VlZC5zbGljZSgxNiwgMzIpKSksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoY2hlY2tzdW0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrc3VtICE9PSAoMCwgZXRoZXJldW1qc191dGlsXzEuc2hhMjU2KSgoMCwgZXRoZXJldW1qc191dGlsXzEuc2hhMjU2KShwcml2YXRlS2V5KSkuc2xpY2UoMCwgOCkudG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBpbnB1dCAtIHBvc3NpYmx5IGludmFsaWQgcGFzc3BocmFzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgZW50cm9weSB0eXBlJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgaW5kZXhfMS5kZWZhdWx0KHByaXZhdGVLZXkpO1xufVxuZXhwb3J0cy5mcm9tS3J5cHRvS2l0ID0gZnJvbUtyeXB0b0tpdDtcbi8qKlxuICogVGhpcmQgUGFydHkgQVBJOiBJbXBvcnQgYSBicmFpbiB3YWxsZXQgdXNlZCBieSBRdW9ydW0gV2FsbGV0XG4gKi9cbmZ1bmN0aW9uIGZyb21RdW9ydW1XYWxsZXQocGFzc3BocmFzZSwgdXNlcmlkKSB7XG4gICAgaWYgKHBhc3NwaHJhc2UubGVuZ3RoIDwgMTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzcGhyYXNlIG11c3QgYmUgYXQgbGVhc3QgMTAgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgICBpZiAodXNlcmlkLmxlbmd0aCA8IDEwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBpZCBtdXN0IGJlIGF0IGxlYXN0IDEwIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkID0gcGFzc3BocmFzZSArIHVzZXJpZDtcbiAgICBjb25zdCBzZWVkID0gY3J5cHRvLnBia2RmMlN5bmMobWVyZ2VkLCBtZXJnZWQsIDIwMDAsIDMyLCAnc2hhMjU2Jyk7XG4gICAgcmV0dXJuIG5ldyBpbmRleF8xLmRlZmF1bHQoc2VlZCk7XG59XG5leHBvcnRzLmZyb21RdW9ydW1XYWxsZXQgPSBmcm9tUXVvcnVtV2FsbGV0O1xuY29uc3QgVGhpcmRwYXJ0eSA9IHtcbiAgICBmcm9tRXRoZXJXYWxsZXQsXG4gICAgZnJvbUV0aGVyQ2FtcCxcbiAgICBmcm9tS3J5cHRvS2l0LFxuICAgIGZyb21RdW9ydW1XYWxsZXQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gVGhpcmRwYXJ0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoaXJkcGFydHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-wallet/dist/thirdparty.js\n");

/***/ })

};
;